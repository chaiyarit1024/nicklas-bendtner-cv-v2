<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Train Journey üöÇ - Nature Edition</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffb77b;
            /* Sunset orange default */
            font-family: 'Kanit', sans-serif;
            color: #333;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Clean Daylight UI */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        header {
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 15px;
            /* Soft gradient overlay for readability */
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.7) 0%, rgba(255, 255, 255, 0) 100%);
        }

        .title-container {
            pointer-events: auto;
        }

        h1 {
            margin: 0;
            font-size: 2.2rem;
            font-weight: 600;
            color: #d35400;
            /* Dark orange */
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.8);
        }

        h1 span {
            color: #27ae60;
            /* Forest green */
        }

        .subtitle {
            font-size: 0.9rem;
            color: #555;
            margin-top: 2px;
        }

        .dashboard {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px;
            padding: 15px 20px;
            width: 250px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            border-top: 4px solid #f39c12;
        }

        .dash-row {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dash-row:last-child {
            margin-bottom: 0;
        }

        .dash-label {
            font-size: 0.85rem;
            color: #7f8c8d;
            font-weight: 600;
        }

        .dash-value {
            font-size: 1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .dash-value.highlight {
            color: #d35400;
        }

        footer {
            padding: 15px 30px;
            display: flex;
            justify-content: flex-end;
            background: linear-gradient(0deg, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 100%);
        }

        .controls-hint {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: #555;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffb77b;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loader-ring {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        /* City Label Styling */
        .city-label {
            color: #2c3e50;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #27ae60;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Kanit', sans-serif;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            margin-top: -15px;
            white-space: nowrap;
        }

        .city-label.destination {
            border-color: #c0392b;
            color: #c0392b;
        }

        /* Camera Toggle Buttons */
        .camera-toggle {
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .cam-btn {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #27ae60;
            color: #2c3e50;
            padding: 8px 15px;
            border-radius: 8px;
            font-family: 'Kanit', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .cam-btn.active {
            background: #27ae60;
            color: white;
            box-shadow: 0 4px 10px rgba(39, 174, 96, 0.4);
        }

        .cam-btn:hover {
            transform: translateY(-2px);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="loading">
        <div class="loader-ring"></div>
        <div style="color: #fff; font-size: 1.2rem; font-weight: 600;">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏π‡πà‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥...</div>
    </div>

    <div id="hud">
        <header>
            <div class="title-container">
                <h1>Forest <span>Journey</span></h1>
                <div class="subtitle">‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏±‡∏ô‡πÅ‡∏™‡∏ô‡∏™‡∏á‡∏ö</div>
                <div class="camera-toggle" style="margin-top: 15px;">
                    <button class="cam-btn active" id="btn-follow">üé• ‡∏ï‡∏≤‡∏°‡∏ï‡∏¥‡∏î‡∏£‡∏ñ‡πÑ‡∏ü</button>
                    <button class="cam-btn" id="btn-free">üåç ‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏≠‡∏¥‡∏™‡∏£‡∏∞</button>
                </div>
            </div>
            <div class="dashboard">
                <div class="dash-row">
                    <span class="dash-label">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</span>
                    <span class="dash-value highlight">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á üöÇ</span>
                </div>
                <div class="dash-row">
                    <span class="dash-label">‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á</span>
                    <span class="dash-value" id="loc-display">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...</span>
                </div>
                <div class="dash-row">
                    <span class="dash-label">‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà</span>
                    <span class="dash-value highlight" id="bat-display">--</span>
                </div>
            </div>
        </header>
        <footer>
            <div class="controls-hint">üñ±Ô∏è ‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á | ‚öôÔ∏è ‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤-‡∏≠‡∏≠‡∏Å | üåç ‡πÇ‡∏î‡∏¢ ‡πÄ‡∏ï‡πä‡∏Å Oracle</div>
        </footer>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- 1. Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // Warm Sunset / Golden Hour Colors
        const fogColor = new THREE.Color(0xffb77b);
        scene.background = fogColor;
        // Reduce fog density
        scene.fog = new THREE.FogExp2(fogColor, 0.005);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);

        // Optimize renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Limit pixel ratio to 1.5 max to reduce lag on high-res displays
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        container.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Lock above ground
        controls.minDistance = 5;
        controls.maxDistance = 80;

        // --- 2. Lighting ---
        // Warm ambient light
        const ambientLight = new THREE.AmbientLight(0xffeedd, 0.6);
        scene.add(ambientLight);

        // Golden Hour Sun (Directional Light)
        const dirLight = new THREE.DirectionalLight(0xffaa55, 1.2);
        dirLight.position.set(20, 30, 20);
        dirLight.castShadow = true;

        // Optimize shadow map size for better performance (less lag)
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // --- 3. Environment (Forest) ---
        // Ground
        const planeGeo = new THREE.PlaneGeometry(300, 300);
        const planeMat = new THREE.MeshLambertMaterial({ color: 0x6e9f50 }); // Soft grass green
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Simple Low-Poly Trees (Instances or merged geometry would be better, but loop is fine for < 100)
        const treeGroup = new THREE.Group();
        const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1, 5);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
        const leavesGeo = new THREE.ConeGeometry(1.2, 3, 5);
        const leavesMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 }); // Darker green

        // Reduce number of trees to 80 to prevent lag
        for (let i = 0; i < 80; i++) {
            const tree = new THREE.Group();

            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            tree.add(trunk);

            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 2.5;
            leaves.castShadow = true;
            tree.add(leaves);

            // Random scale
            const scale = Math.random() * 1.5 + 0.8;
            tree.scale.set(scale, scale, scale);

            // Random position
            let rx = (Math.random() - 0.5) * 120;
            let rz = (Math.random() - 0.5) * 120;

            // Keep center clear for the track
            if (Math.abs(rx) < 5) rx = Math.sign(rx) * (Math.random() * 20 + 5);
            if (Math.abs(rz) < 5) rz = Math.sign(rz) * (Math.random() * 20 + 5);

            tree.position.set(rx, 0, rz);
            treeGroup.add(tree);
        }
        scene.add(treeGroup);

        // --- 4. The Premium Multi-Carriage Express ---
        const trainCars = [];
        const numCars = 4; // Locomotive + 3 passenger carriages
        
        // Exquisite Materials
        const bodyMat = new THREE.MeshPhysicalMaterial({ 
            color: 0xffffff, // Pearl White
            metalness: 0.1, 
            roughness: 0.1, 
            clearcoat: 1.0, 
            clearcoatRoughness: 0.1
        });
        const darkMetal = new THREE.MeshPhysicalMaterial({ color: 0x1a1a24, metalness: 0.8, roughness: 0.4 });
        const glassMat = new THREE.MeshPhysicalMaterial({ 
            color: 0x011125, // Deep tinted glass
            metalness: 0.9, 
            roughness: 0.0, 
            transmission: 0.8,
            transparent: true,
            opacity: 1
        });
        const accentMat = new THREE.MeshLambertMaterial({ color: 0x00d2ff, emissive: 0x0055ff, emissiveIntensity: 1.5 }); // Cyan glow
        const warmLight = new THREE.MeshLambertMaterial({ color: 0xffffff, emissive: 0xffeedd, emissiveIntensity: 3 }); // Headlights

        function createCarriage(isLoco) {
            const car = new THREE.Group();
            
            // Core chassis
            const length = isLoco ? 5.5 : 4.8;
            const bodyY = 1.3;
            
            const geoBody = new THREE.BoxGeometry(1.8, 1.8, length);
            const meshBody = new THREE.Mesh(geoBody, bodyMat);
            meshBody.position.y = bodyY;
            meshBody.castShadow = true;
            meshBody.receiveShadow = true;
            car.add(meshBody);

            // Sleek side windows strip
            const geoWindow = new THREE.BoxGeometry(1.85, 0.7, length - 0.4);
            const meshWindow = new THREE.Mesh(geoWindow, glassMat);
            meshWindow.position.y = bodyY + 0.2;
            car.add(meshWindow);

            // Aerodynamic Base
            const geoBase = new THREE.BoxGeometry(1.6, 0.6, length - 0.2);
            const meshBase = new THREE.Mesh(geoBase, darkMetal);
            meshBase.position.y = 0.5;
            car.add(meshBase);

            // Roof details (AC loops, slick profile)
            const geoRoof = new THREE.BoxGeometry(1.2, 0.15, length - 0.5);
            const meshRoof = new THREE.Mesh(geoRoof, darkMetal);
            meshRoof.position.y = bodyY + 0.95;
            car.add(meshRoof);

            // Cyan Power Stripe along side
            const geoStripe = new THREE.BoxGeometry(1.82, 0.1, length);
            const meshStripe = new THREE.Mesh(geoStripe, accentMat);
            meshStripe.position.y = bodyY - 0.5;
            car.add(meshStripe);

            if (isLoco) {
                // Bullet Train aerodynamic nose pointing towards +z
                const noseLength = 2.5;
                const noseCurve = new THREE.CylinderGeometry(0.01, 0.9, noseLength, 32);
                const nose = new THREE.Mesh(noseCurve, bodyMat);
                nose.rotation.x = Math.PI / 2;
                nose.scale.set(1, 0.9, 1);
                nose.position.set(0, bodyY - 0.05, length/2 + noseLength/2);
                car.add(nose);

                // Driver's front glass sweeping back
                const driverGlass = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.85, 1.5, 32, 1, false, 0, Math.PI), glassMat);
                driverGlass.rotation.x = Math.PI / 2;
                driverGlass.position.set(0, bodyY + 0.35, length/2 + 0.2);
                car.add(driverGlass);

                // Headlights integrated into the nose
                const hlFront = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.4), warmLight);
                hlFront.position.set(0, bodyY - 0.6, length/2 + 1.8);
                car.add(hlFront);

                // Heavy Spotlight lighting the track ahead
                const spotLight = new THREE.SpotLight(0xffffee, 6);
                spotLight.position.set(0, bodyY - 0.6, length/2 + 2.0);
                spotLight.target.position.set(0, 0, 40);
                spotLight.angle = Math.PI / 5;
                spotLight.penumbra = 0.5;
                spotLight.distance = 120;
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 1024;
                spotLight.shadow.mapSize.height = 1024;
                car.add(spotLight);
                car.add(spotLight.target);
            } else {
                // Flexible Connector (Bellows) at front of carriage to attach to previous car
                const bellowsGeo = new THREE.BoxGeometry(1.3, 1.6, 0.8);
                const bellows = new THREE.Mesh(bellowsGeo, darkMetal);
                bellows.position.set(0, bodyY, length/2 + 0.4);
                car.add(bellows);
            }
            
            return car;
        }

        for (let i = 0; i < numCars; i++) {
            const car = createCarriage(i === 0);
            trainCars.push(car);
            scene.add(car);
        }

        // --- 5. Data Fetching & Path Generation ---
        const csvUrl = 'https://raw.githubusercontent.com/Soul-Brews-Studio/two-rivers-oracle/main/%CF%88/lab/github-pages-workshop/travel-phitsanulok.csv';

        let pathCurve;
        let waypointsData = [];
        let animationActive = false;

        fetch(csvUrl)
            .then(res => res.text())
            .then(csvText => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function (results) {
                        const data = results.data;
                        data.sort((a, b) => new Date(a.updated) - new Date(b.updated));

                        // Sample data (every 5th point)
                        const sampledData = [];
                        data.forEach((row, index) => {
                            if (index === 0 || index === data.length - 1 || index % 5 === 0) {
                                sampledData.push(row);
                            }
                        });

                        buildPath(sampledData);
                    }
                });
            });

        function createLabel(text, isDestination = false) {
            const div = document.createElement('div');
            div.className = isDestination ? 'city-label destination' : 'city-label';
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.set(0, 2, 0);
            return label;
        }

        function buildPath(data) {
            waypointsData = data;

            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            data.forEach(p => {
                const lat = parseFloat(p.lat); const lon = parseFloat(p.lon);
                if (lat < minLat) minLat = lat; if (lat > maxLat) maxLat = lat;
                if (lon < minLon) minLon = lon; if (lon > maxLon) maxLon = lon;
            });

            const points3D = [];

            data.forEach((p, index) => {
                const lat = parseFloat(p.lat);
                const lon = parseFloat(p.lon);

                // Map coordinates
                const x = THREE.MathUtils.mapLinear(lon, minLon, maxLon, -40, 40);
                const z = THREE.MathUtils.mapLinear(lat, minLat, maxLat, 30, -30);

                const vec = new THREE.Vector3(x, 0, z);
                points3D.push(vec);

                // Markers for start/end
                if (index === 0 || index === data.length - 1) {
                    const markerGeo = new THREE.SphereGeometry(0.8, 16, 16);
                    const isEnd = index === data.length - 1;
                    const markerMat = new THREE.MeshLambertMaterial({
                        color: isEnd ? 0xe74c3c : 0x2ecc71
                    });
                    const marker = new THREE.Mesh(markerGeo, markerMat);
                    marker.position.copy(vec);
                    scene.add(marker);

                    if (index === 0) marker.add(createLabel('‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà)'));
                    if (isEnd) marker.add(createLabel('‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (‡∏û‡∏¥‡∏©‡∏ì‡∏∏‡πÇ‡∏•‡∏Å)', true));
                }
            });

            // Curve for smooth movement
            pathCurve = new THREE.CatmullRomCurve3(points3D);
            pathCurve.tension = 0.5;

            // Simple Track (Wooden looking)
            const trackGeo = new THREE.TubeGeometry(pathCurve, 100, 0.3, 6, false);
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x7f8c8d });
            const trackMesh = new THREE.Mesh(trackGeo, trackMat);
            scene.add(trackMesh);

            // Hide loaded
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 500);

            animationActive = true;
        }

        // --- 6. Animation Logic ---
        const clock = new THREE.Clock();
        let t = 0;
        const animationSpeed = 0.02; // Steady, safe speed

        // Camera control state
        let cameraMode = 'follow'; // 'follow' | 'free'

        const btnFollow = document.getElementById('btn-follow');
        const btnFree = document.getElementById('btn-free');

        btnFollow.addEventListener('click', () => {
            cameraMode = 'follow';
            btnFollow.classList.add('active');
            btnFree.classList.remove('active');
        });

        btnFree.addEventListener('click', () => {
            cameraMode = 'free';
            btnFree.classList.add('active');
            btnFollow.classList.remove('active');
        });

        let isUserControlling = false;
        controls.addEventListener('start', () => { isUserControlling = true; });

        let controlTimeout;
        controls.addEventListener('end', () => {
            clearTimeout(controlTimeout);
            controlTimeout = setTimeout(() => { isUserControlling = false; }, 3000);
        });

        function animate() {
            requestAnimationFrame(animate);

            if (animationActive && pathCurve) {
                const delta = clock.getDelta();
                t += delta * animationSpeed;
                if (t >= 1) t = 0;

                // Calculate physical gap dynamically or statically
                // Each car is approx 5-6 units. 
                const tSpacing = 0.012; // Gap between cars on the curve

                let headPos = new THREE.Vector3();
                let headLookAt = new THREE.Vector3();

                // Move all cars, weaving them closely together
                trainCars.forEach((car, index) => {
                    let carT = t - (index * tSpacing);
                    if (carT < 0) carT += 1;

                    const position = pathCurve.getPointAt(carT);
                    car.position.copy(position);

                    const nextT = (carT + 0.002 > 1) ? 1 : carT + 0.002;
                    const lookAtPt = pathCurve.getPointAt(nextT);
                    car.lookAt(lookAtPt);

                    if (index === 0) {
                        headPos.copy(position);
                        headLookAt.copy(lookAtPt);
                    }
                });

                // Camera Logic targets the Locomotive
                if (cameraMode === 'follow') {
                    if (!isUserControlling) {
                        const tangent = new THREE.Vector3().subVectors(headLookAt, headPos).normalize();
                        const cameraOffset = new THREE.Vector3().copy(headPos)
                            .sub(tangent.multiplyScalar(15)) // Distance behind head
                            .add(new THREE.Vector3(0, 8, 0)); // Height

                        camera.position.lerp(cameraOffset, 0.05);
                        controls.target.lerp(headPos, 0.08);
                    }
                }

                // Update UI Location Name
                const dataIndex = Math.floor(t * waypointsData.length);
                if (waypointsData[dataIndex]) {
                    const row = waypointsData[dataIndex];
                    const place = row.place || row.locality || "‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏õ‡πà‡∏≤‡πÄ‡∏Ç‡∏≤";
                    document.getElementById('loc-display').innerText = place;
                    document.getElementById('bat-display').innerText = row.battery ? Math.round(row.battery) + "%" : "--";
                }
            }

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>